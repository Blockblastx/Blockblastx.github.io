
// Immediately-invoked function expression to avoid polluting the global namespace
(function() {
    'use strict';
    
    let originalStartDragging, originalEndDragging, originalMoveDragElement;
    let originalUpdateGridHighlight, originalTryPlaceBlock;
    
    // Wait for the document to be fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        console.log("Drag fix patch loaded");
        
        // Make sure the game is initialized before attempting to patch
        let checkInterval = setInterval(function() {
            // Check if the main drag manager has been initialized
            if (window.currentDrag) {
                console.log("Main game detected, applying drag fix patch");
                applyDragFix();
                clearInterval(checkInterval);
            }
        }, 500);
    });
    
    // Apply drag fix by patching the DragManager functions
    function applyDragFix() {
        try {
            console.log("Starting to apply drag fix");
            
            // Patch the startDragging function on the window object
            // This works even if DragManager is not directly accessible
            window.DragManager = window.DragManager || {};
            
            const originalStartDragging = window.DragManager.startDragging;
            window.DragManager.startDragging = function(blockId, element, offsetX, offsetY, clientX, clientY) {
                console.log("Using patched startDragging function");
                
                // If there's already an ongoing drag operation, clean it up first
                if (window.currentDrag.element) {
                    window.DragManager.endDragging();
                }
                
                try {
                    // Clone the element for dragging
                    const clone = element.cloneNode(true);
                    clone.classList.add('dragging');
                    
                    // IMPORTANT FIX: Append directly to body for unrestricted movement
                    document.body.appendChild(clone);
                    
                    // Get the dimensions for proper positioning
                    const rect = element.getBoundingClientRect();
                    
                    // IMPORTANT FIX: Fixed position relative to viewport instead of parent container
                    clone.style.position = 'fixed'; // Changed from 'absolute' to 'fixed'
                    clone.style.left = (clientX - rect.width / 2) + 'px';
                    clone.style.top = (clientY - rect.height / 2) + 'px';
                    clone.style.zIndex = '10000'; // Ensure it's above everything
                    
                    // Add ARIA for accessibility
                    clone.setAttribute('aria-grabbed', 'true');
                    
                    // Hide original element
                    element.style.visibility = 'hidden';
                    
                    // Store drag information
                    window.currentDrag.blockId = blockId;
                    window.currentDrag.element = clone;
                    window.currentDrag.originalElement = element;
                    window.currentDrag.offsetX = rect.width / 2;
                    window.currentDrag.offsetY = rect.height / 2;
                    
                    // Fire custom event for screen readers
                    const dragStartEvent = new CustomEvent('blockdragstart', { 
                        detail: { blockId, clientX, clientY } 
                    });
                    document.dispatchEvent(dragStartEvent);
                    
                    return window.currentDrag;
                } catch (error) {
                    console.error("Error in patched startDragging:", error);
                    // Ensure original element is visible if an error occurs
                    if (element) {
                        element.style.visibility = 'visible';
                    }
                    return null;
                }
            };
            
            // Store original functions if they exist
            const originalMoveDragElement = window.DragManager.moveDragElement;
            const originalEndDragging = window.DragManager.endDragging;
            const originalUpdateGridHighlight = window.DragManager.updateGridHighlight;
            
            // Patch the moveDragElement function
            window.DragManager.moveDragElement = function(clientX, clientY) {
                //console.log("Using patched moveDragElement");
                if (!window.currentDrag.element) return;
                
                // Cancel any existing animation frame
                if (window.movementAnimationFrame) {
                    cancelAnimationFrame(window.movementAnimationFrame);
                }
                
                // Schedule the movement for the next frame
                window.movementAnimationFrame = requestAnimationFrame(() => {
                    if (window.currentDrag.element) {
                        // IMPORTANT FIX: Use fixed positioning for viewport-relative coordinates
                        window.currentDrag.element.style.left = (clientX - window.currentDrag.offsetX) + 'px';
                        window.currentDrag.element.style.top = (clientY - window.currentDrag.offsetY) + 'px';
                    }
                    window.movementAnimationFrame = null;
                });
            };
            
            // Fix touch event handling directly
            // Create a new touchmove handler that doesn't rely on BLOCKS
            const fixedTouchMoveHandler = function(e) {
                if (window.GameState && window.GameState.gameOver) return;
                
                // IMPORTANT FIX: Only prevent default and handle events if we have an active drag
                if (window.currentDrag && window.currentDrag.element) {
                    const touch = e.touches[0];
                    
                    window.DragManager.moveDragElement(touch.clientX, touch.clientY);
                    
                    // Only call updateGridHighlight if we can safely do so
                    try {
                        if (window.DragManager.updateGridHighlight && window.UIManager && window.UIManager.showPlacementPreview) {
                            window.DragManager.updateGridHighlight(touch.clientX, touch.clientY, null, function(blockId, shape, gridX, gridY) {
                                window.UIManager.showPlacementPreview(blockId, shape, gridX, gridY);
                            });
                        }
                    } catch (err) {
                        console.log("Safe grid highlight error:", err);
                    }
                    
                    // Prevent scrolling while dragging
                    e.preventDefault();
                }
            };
            
            // Remove existing touchmove handlers and add our fixed one
            // First, create a version that will work with any event listener
            document.addEventListener('touchmove', fixedTouchMoveHandler, { passive: false });
            
            console.log("Drag fix patch applied successfully");
        } catch (e) {
            console.error("Failed to apply drag fix patch:", e);
        }
    }
})();


///Version 2
